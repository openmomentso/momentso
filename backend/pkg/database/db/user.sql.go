// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: user.sql

package db

import (
	"context"
)

const listTimeEntries = `-- name: ListTimeEntries :many
select id, description, workspace_id, created_by, created_at, started_at, completed_at from time_entries
`

func (q *Queries) ListTimeEntries(ctx context.Context) ([]TimeEntry, error) {
	rows, err := q.db.QueryContext(ctx, listTimeEntries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TimeEntry
	for rows.Next() {
		var i TimeEntry
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.WorkspaceID,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const sessionCreate = `-- name: SessionCreate :one
insert into sessions (user_id, token) values ($1, $2) returning id, user_id, token, created_at
`

type SessionCreateParams struct {
	UserID int64
	Token  string
}

func (q *Queries) SessionCreate(ctx context.Context, arg SessionCreateParams) (Session, error) {
	row := q.db.QueryRowContext(ctx, sessionCreate, arg.UserID, arg.Token)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.CreatedAt,
	)
	return i, err
}

const userCreate = `-- name: UserCreate :one
insert into users (email, password) values ($1, $2) returning id, email, password, workspace_id, created_at
`

type UserCreateParams struct {
	Email    string
	Password string
}

func (q *Queries) UserCreate(ctx context.Context, arg UserCreateParams) (User, error) {
	row := q.db.QueryRowContext(ctx, userCreate, arg.Email, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.WorkspaceID,
		&i.CreatedAt,
	)
	return i, err
}

const userFind = `-- name: UserFind :many
select id, email, password, workspace_id, created_at from users
`

func (q *Queries) UserFind(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, userFind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Password,
			&i.WorkspaceID,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userFindByEmail = `-- name: UserFindByEmail :one
select id, email, password, workspace_id, created_at from users where email = $1
`

func (q *Queries) UserFindByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, userFindByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.WorkspaceID,
		&i.CreatedAt,
	)
	return i, err
}

const userFindById = `-- name: UserFindById :one
select id, email, password, workspace_id, created_at from users where id = $1
`

func (q *Queries) UserFindById(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRowContext(ctx, userFindById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.WorkspaceID,
		&i.CreatedAt,
	)
	return i, err
}

const userFindBySession = `-- name: UserFindBySession :one
select id, email, password, workspace_id, created_at from users where id = (select user_id from sessions where token = $1 and users.created_at > now() - interval '30 days')
`

func (q *Queries) UserFindBySession(ctx context.Context, token string) (User, error) {
	row := q.db.QueryRowContext(ctx, userFindBySession, token)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.WorkspaceID,
		&i.CreatedAt,
	)
	return i, err
}
