// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: user.sql

package db

import (
	"context"
)

const listTimeEntries = `-- name: ListTimeEntries :many
select id, description, created_by, created_at, started_at, completed_at, project_id from time_entries
`

func (q *Queries) ListTimeEntries(ctx context.Context) ([]TimeEntry, error) {
	rows, err := q.db.Query(ctx, listTimeEntries)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TimeEntry
	for rows.Next() {
		var i TimeEntry
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.ProjectID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const passwordResetDelete = `-- name: PasswordResetDelete :exec
delete from password_reset_tokens where user_id = $1
`

func (q *Queries) PasswordResetDelete(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, passwordResetDelete, userID)
	return err
}

const passwordResetSet = `-- name: PasswordResetSet :exec
insert into password_reset_tokens (user_id, token) values ($1, $2) on conflict (user_id) do update set token = $2, created_at = now()
`

type PasswordResetSetParams struct {
	UserID int64  `db:"user_id"`
	Token  string `db:"token"`
}

func (q *Queries) PasswordResetSet(ctx context.Context, arg PasswordResetSetParams) error {
	_, err := q.db.Exec(ctx, passwordResetSet, arg.UserID, arg.Token)
	return err
}

const sessionCreate = `-- name: SessionCreate :one
insert into sessions (user_id, token) values ($1, $2) returning id, user_id, token, created_at
`

type SessionCreateParams struct {
	UserID int64  `db:"user_id"`
	Token  string `db:"token"`
}

func (q *Queries) SessionCreate(ctx context.Context, arg SessionCreateParams) (Session, error) {
	row := q.db.QueryRow(ctx, sessionCreate, arg.UserID, arg.Token)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.CreatedAt,
	)
	return i, err
}

const userCreate = `-- name: UserCreate :one
insert into users (email, password) values ($1, $2) returning id, email, password, created_at
`

type UserCreateParams struct {
	Email    string `db:"email"`
	Password string `db:"password"`
}

func (q *Queries) UserCreate(ctx context.Context, arg UserCreateParams) (User, error) {
	row := q.db.QueryRow(ctx, userCreate, arg.Email, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
	)
	return i, err
}

const userFind = `-- name: UserFind :many
select id, email, password, created_at from users
`

func (q *Queries) UserFind(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, userFind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.Password,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const userFindByEmail = `-- name: UserFindByEmail :one
select id, email, password, created_at from users where email = $1
`

func (q *Queries) UserFindByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, userFindByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
	)
	return i, err
}

const userFindById = `-- name: UserFindById :one
select id, email, password, created_at from users where id = $1
`

func (q *Queries) UserFindById(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, userFindById, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
	)
	return i, err
}

const userFindByPasswordResetToken = `-- name: UserFindByPasswordResetToken :one
select u.id, u.email, u.password, u.created_at from password_reset_tokens p
inner join users u on u.id = p.user_id
where token = $1 and p.created_at > now() - interval '30 minutes'
`

func (q *Queries) UserFindByPasswordResetToken(ctx context.Context, token string) (User, error) {
	row := q.db.QueryRow(ctx, userFindByPasswordResetToken, token)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
	)
	return i, err
}

const userFindBySession = `-- name: UserFindBySession :one
select id, email, password, created_at from users where id = (select user_id from sessions where token = $1 and users.created_at > now() - interval '30 days')
`

func (q *Queries) UserFindBySession(ctx context.Context, token string) (User, error) {
	row := q.db.QueryRow(ctx, userFindBySession, token)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Password,
		&i.CreatedAt,
	)
	return i, err
}

const userUpdatePassword = `-- name: UserUpdatePassword :exec
update users set password = $2 where id = $1
`

type UserUpdatePasswordParams struct {
	ID       int64  `db:"id"`
	Password string `db:"password"`
}

func (q *Queries) UserUpdatePassword(ctx context.Context, arg UserUpdatePasswordParams) error {
	_, err := q.db.Exec(ctx, userUpdatePassword, arg.ID, arg.Password)
	return err
}
