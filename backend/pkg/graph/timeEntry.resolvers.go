package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.38

import (
	"context"
	"errors"
	"time"

	sq "github.com/Masterminds/squirrel"
	pgx "github.com/jackc/pgx/v5"
	"github.com/openmomentso/momentso/pkg/app/auth"
	"github.com/openmomentso/momentso/pkg/database"
	"github.com/openmomentso/momentso/pkg/database/db"
	"github.com/openmomentso/momentso/pkg/graph/model"
)

// CreateTimeEntry is the resolver for the createTimeEntry field.
func (r *mutationResolver) CreateTimeEntry(ctx context.Context, input model.CreateTimeEntryInput) (*model.CreateTimeEntryPayload, error) {
	user, ok := auth.UserForCtx(ctx)
	if !ok {
		return nil, errors.New("unauthorized")
	}

	var dbStartedAt time.Time
	if input.StartedAt == nil {
		dbStartedAt = time.Now()
	} else {
		dbStartedAt = *input.StartedAt
	}

	entry, err := r.DB.TimeEntryCreate(ctx, db.TimeEntryCreateParams{
		CreatedBy:   user.ID,
		StartedAt:   dbStartedAt,
		Description: input.Description,
	})
	if err != nil {
		return nil, err
	}

	return &model.CreateTimeEntryPayload{
		TimeEntry: entry,
	}, nil
}

// UpdateTimeEntry is the resolver for the updateTimeEntry field.
func (r *mutationResolver) UpdateTimeEntry(ctx context.Context, id int64, input map[string]interface{}) (*model.UpdateTimeEntryPayload, error) {
	user, ok := auth.UserForCtx(ctx)
	if !ok {
		return nil, errors.New("unauthorized")
	}

	if len(input) == 0 {
		return nil, errors.New("no input provided")
	}

	update := r.DB.NewQueryBuilder().Update("time_entries").Where(sq.Eq{"id": id, "created_by": user.ID}).Suffix("returning *")
	for key, value := range input {
		switch key {
		case "description":
			update = update.Set("description", value)
		case "startedAt":
			update = update.Set("started_at", value)
		case "completedAt":
			update = update.Set("completed_at", value)
		}
	}

	updatedEntry, err := database.ScanUpdateOne[db.TimeEntry](r.DB, ctx, update)
	return &model.UpdateTimeEntryPayload{
		TimeEntry: updatedEntry,
	}, err
}

// TimeEntries is the resolver for the timeEntries field.
func (r *queryResolver) TimeEntries(ctx context.Context) (*model.TimeEntryConnection, error) {
	user, ok := auth.UserForCtx(ctx)
	if !ok {
		return nil, errors.New("unauthorized")
	}

	entries, err := r.DB.TimeEntryFind(ctx, user.ID)
	if err != nil {
		return nil, err
	}

	return &model.TimeEntryConnection{
		Edges: entries,
	}, nil
}

// TimeEntry is the resolver for the timeEntry field.
func (r *queryResolver) TimeEntry(ctx context.Context, id int64) (*db.TimeEntry, error) {
	user, ok := auth.UserForCtx(ctx)
	if !ok {
		return nil, errors.New("unauthorized")
	}

	entry, err := r.DB.TimeEntryFindById(ctx, db.TimeEntryFindByIdParams{
		ID:        id,
		CreatedBy: user.ID,
	})
	return &entry, err
}

// RunningTimeEntry is the resolver for the runningTimeEntry field.
func (r *queryResolver) RunningTimeEntry(ctx context.Context) (*db.TimeEntry, error) {
	user, ok := auth.UserForCtx(ctx)
	if !ok {
		return nil, errors.New("unauthorized")
	}

	entry, err := r.DB.TimeEntryFindRunning(ctx, user.ID)
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, nil
	} else if err != nil {
		return nil, err
	}
	return &entry, nil
}

// CreatedBy is the resolver for the createdBy field.
func (r *timeEntryResolver) CreatedBy(ctx context.Context, obj *db.TimeEntry) (*db.User, error) {
	// todo: loader
	user, err := r.DB.UserFindById(ctx, obj.CreatedBy)
	return &user, err
}

// CompletedAt is the resolver for the completedAt field.
func (r *timeEntryResolver) CompletedAt(ctx context.Context, obj *db.TimeEntry) (*time.Time, error) {
	if obj.CompletedAt.Valid {
		return &obj.CompletedAt.Time, nil
	}

	return nil, nil
}

// Project is the resolver for the project field.
func (r *timeEntryResolver) Project(ctx context.Context, obj *db.TimeEntry) (*db.Project, error) {
	user, ok := auth.UserForCtx(ctx)
	if !ok {
		return nil, errors.New("unauthorized")
	}

	if !obj.ProjectID.Valid {
		return nil, nil
	}

	// todo: loader
	project, err := r.DB.ProjectFindByID(ctx, db.ProjectFindByIDParams{
		ID:     obj.ProjectID.Int64,
		UserID: user.ID,
	})
	return &project, err
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// TimeEntry returns TimeEntryResolver implementation.
func (r *Resolver) TimeEntry() TimeEntryResolver { return &timeEntryResolver{r} }

type queryResolver struct{ *Resolver }
type timeEntryResolver struct{ *Resolver }
