package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.38

import (
	"context"
	"errors"
	"time"

	sq "github.com/Masterminds/squirrel"

	"github.com/openmomentso/momentso/pkg/app/auth"
	"github.com/openmomentso/momentso/pkg/database"
	"github.com/openmomentso/momentso/pkg/database/db"
	"github.com/openmomentso/momentso/pkg/graph/model"
)

// CreateTimeEntry is the resolver for the createTimeEntry field.
func (r *mutationResolver) CreateTimeEntry(ctx context.Context, input model.CreateTimeEntryInput) (*model.CreateTimeEntryPayload, error) {
	user, ok := auth.UserForCtx(ctx)
	if !ok {
		return nil, errors.New("unauthorized")
	}

	var dbStartedAt time.Time
	if input.StartedAt == nil {
		dbStartedAt = time.Now()
	} else {
		dbStartedAt = *input.StartedAt
	}

	entry, err := r.DB.TimeEntryCreate(ctx, db.TimeEntryCreateParams{
		CreatedBy:   user.ID,
		StartedAt:   dbStartedAt,
		Description: input.Description,
	})
	if err != nil {
		return nil, err
	}

	return &model.CreateTimeEntryPayload{
		TimeEntry: entry,
	}, nil
}

// UpdateTimeEntry is the resolver for the updateTimeEntry field.
func (r *mutationResolver) UpdateTimeEntry(ctx context.Context, id int64, input map[string]interface{}) (*model.UpdateTimeEntryPayload, error) {
	user, ok := auth.UserForCtx(ctx)
	if !ok {
		return nil, errors.New("unauthorized")
	}

	if len(input) == 0 {
		return nil, errors.New("no input provided")
	}

	update := r.DB.NewQueryBuilder().Update("time_entries").Where(sq.Eq{"id": id, "created_by": user.ID}).Suffix("returning *")
	for key, value := range input {
		switch key {
		case "description":
			update = update.Set("description", value)
		case "startedAt":
			update = update.Set("started_at", value)
		case "completedAt":
			update = update.Set("completed_at", value)
		}
	}
	update.ToSql()

	updatedEntry, err := database.ScanUpdateOne[db.TimeEntry](r.DB, ctx, update)
	return &model.UpdateTimeEntryPayload{
		TimeEntry: updatedEntry,
	}, err
}

// TimeEntries is the resolver for the timeEntries field.
func (r *queryResolver) TimeEntries(ctx context.Context) (*model.TimeEntryConnection, error) {
	user, ok := auth.UserForCtx(ctx)
	if !ok {
		return nil, errors.New("unauthorized")
	}

	entries, err := r.DB.TimeEntryFind(ctx, user.ID)
	if err != nil {
		return nil, err
	}

	return &model.TimeEntryConnection{
		Edges: entries,
	}, nil
}

// TimeEntry is the resolver for the timeEntry field.
func (r *queryResolver) TimeEntry(ctx context.Context, id int64) (*db.TimeEntry, error) {
	user, ok := auth.UserForCtx(ctx)
	if !ok {
		return nil, errors.New("unauthorized")
	}

	entry, err := r.DB.TimeEntryFindById(ctx, db.TimeEntryFindByIdParams{
		ID:        id,
		CreatedBy: user.ID,
	})
	return &entry, err
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
